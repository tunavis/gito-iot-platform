# Database Migrations with Alembic

## Overview

This project uses [Alembic](https://alembic.sqlalchemy.org/) for database migrations - the industry-standard tool for SQLAlchemy projects.

## How It Works

**Automatic on Startup:**
- Migrations run automatically when the API container starts
- No manual intervention needed for deployments
- See `api/entrypoint.sh` for the auto-run logic

**Migration Files:**
- Location: `api/alembic/versions/`
- Numbered Python files (generated by Alembic)
- Applied in sequential order
- Tracked in `alembic_version` table

---

## Creating a New Migration

### When You Add/Modify a SQLAlchemy Model:

**Step 1: Update the model**
```python
# api/app/models/my_feature.py
class MyFeature(BaseModel):
    __tablename__ = "my_features"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    tenant_id = Column(UUID(as_uuid=True), ForeignKey("tenants.id"))
    name = Column(String(255), nullable=False)
    # ... etc
```

**Step 2: Import the model**
```python
# api/app/models/__init__.py
from app.models.my_feature import MyFeature

__all__ = [
    # ... existing models
    "MyFeature",  # Add here
]
```

**Step 3: Generate migration**
```bash
# Inside API container
docker exec gito-api alembic revision --autogenerate -m "add_my_feature"
```

**Step 4: Review the generated migration**
```bash
# Check what Alembic detected
cat api/alembic/versions/*_add_my_feature.py
```

**Step 5: Test locally**
```bash
# Restart API (auto-applies migration)
docker-compose restart api

# Check logs
docker logs gito-api | grep "Running upgrade"
```

**Step 6: Commit to git**
```bash
git add api/app/models/my_feature.py
git add api/app/models/__init__.py
git add api/alembic/versions/*_add_my_feature.py
git commit -m "feat: add my feature with database migration"
```

---

## Common Commands

### Check Current Migration Status
```bash
docker exec gito-api alembic current
```

### View Migration History
```bash
docker exec gito-api alembic history
```

### Apply Migrations Manually (usually not needed)
```bash
docker exec gito-api alembic upgrade head
```

### Rollback Last Migration (emergency only!)
```bash
docker exec gito-api alembic downgrade -1
```

---

## Deployment Workflow

### Local → Staging

1. **Developer creates feature branch**
   ```bash
   git checkout -b feature/my-feature
   ```

2. **Add model + generate migration** (as shown above)

3. **Push to staging**
   ```bash
   ssh user@192.168.0.9
   cd /path/to/gito-iot
   git pull origin main
   docker-compose up -d --build  # Auto-runs migrations
   ```

4. **Verify**
   ```bash
   docker logs gito-api | grep "Running upgrade"
   ```

### Staging → Production

Same process - migrations auto-run on container startup.

---

## Best Practices

### ✅ DO:

1. **Always run autogenerate** - Don't manually write migrations
2. **Review generated migrations** - Alembic isn't perfect, check the output
3. **Test locally first** - Apply migration on dev before pushing
4. **Commit migration with code** - Model + migration in same commit
5. **Use descriptive names** - `add_user_roles` not `update_schema`

### ❌ DON'T:

1. **Never modify applied migrations** - Create new ones instead
2. **Never delete migration files** - They're version history
3. **Never manually edit database** - Use migrations only
4. **Never commit without testing** - Always test migration locally

---

## Troubleshooting

### Migration Fails to Apply

**Check the error:**
```bash
docker logs gito-api | tail -50
```

**Common issues:**

1. **Syntax error in SQL**
   - Fix the generated migration file
   - Delete `alembic_version` entry: `DELETE FROM alembic_version WHERE version_num = 'xxx';`
   - Re-apply: `docker-compose restart api`

2. **Column/table already exists**
   - Migration was partially applied
   - Manually fix database to match expected state
   - Mark migration as applied: `INSERT INTO alembic_version VALUES ('xxx');`

3. **Foreign key constraint violation**
   - Data in database doesn't match new schema
   - Fix data first, then re-run migration

### Check What Migration Will Do

```bash
# Generate migration but don't apply
docker exec gito-api alembic revision --autogenerate -m "test"

# Review the file
cat api/alembic/versions/*_test.py

# Delete if not needed
rm api/alembic/versions/*_test.py
```

### Database Out of Sync with Models

**This should never happen if you always use Alembic!**

But if it does:
```bash
# Generate migration to sync
docker exec gito-api alembic revision --autogenerate -m "sync_schema"

# Review what it detected
cat api/alembic/versions/*_sync_schema.py

# Apply
docker-compose restart api
```

---

## Migration File Structure

```python
"""add_my_feature

Revision ID: abc123def456
Revises: previous_migration_id
Create Date: 2026-02-04 12:00:00

"""
from alembic import op
import sqlalchemy as sa

# Revision identifiers
revision = 'abc123def456'
down_revision = 'previous_migration_id'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Applied when upgrading
    op.create_table('my_features',
        sa.Column('id', sa.UUID(), nullable=False),
        sa.Column('tenant_id', sa.UUID(), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.ForeignKeyConstraint(['tenant_id'], ['tenants.id']),
        sa.PrimaryKeyConstraint('id')
    )

def downgrade() -> None:
    # Applied when rolling back
    op.drop_table('my_features')
```

---

## Bridge Device Auto-Discovery (Migration 005)

### Context

The MQTT bridge (`simulation_data/mqtt/bridge_ui.py`) auto-creates devices when it receives
telemetry from an external MQTT broker. It does **not** require a `device_type_id` — the
device type is optional and can be assigned later via the UI.

### What Migration 005 Does

`005_nullable_device_hierarchy` makes four columns nullable on the `devices` table:

| Column | Before | After |
|---|---|---|
| `organization_id` | NOT NULL | NULL allowed |
| `site_id` | NOT NULL | NULL allowed |
| `device_group_id` | NOT NULL | NULL allowed |
| `device_type_id` | NOT NULL | NULL allowed |

Without this migration, the bridge `POST /devices` call fails with:
```
null value in column "device_type_id" of relation "devices" violates not-null constraint
```

### Staging Deploy

Migrations **004 and 005** are applied automatically on the next staging deploy because
`api/entrypoint.sh` runs `alembic upgrade head` on every container start.

```bash
# Verify after deploy
docker exec gito-api alembic current
# Expected: 005_nullable_device_hierarchy (head)
```

### Bridge Device Creation Flow

1. Bridge receives message on external MQTT topic (e.g. `SDE11/JAX/UTILITIES/BOILER/OPT_G/CHIMNEY_TEMP`)
2. Bridge calls `POST /tenants/{id}/devices` — sets `device_type` (varchar) from topic prefix, leaves `device_type_id` as `null`
3. Bridge re-publishes to local Mosquitto as `{tenant}/devices/{device_id}/telemetry`
4. `mqtt_processor` picks it up → writes to `telemetry` table → triggers alerts → WebSocket push
5. Operator assigns `device_type_id` later via the UI to enable schema-driven dashboards

---

## Emergency Procedures

### Need to Rollback Migration in Production

1. **Stop API**
   ```bash
   docker-compose stop api
   ```

2. **Rollback migration**
   ```bash
   docker exec gito-api alembic downgrade -1
   ```

3. **Verify**
   ```bash
   docker exec gito-postgres psql -U gito -d gito -c "\dt"
   ```

4. **Restart API**
   ```bash
   docker-compose start api
   ```

### Database Completely Broken

1. **Backup first!**
   ```bash
   docker exec gito-postgres pg_dump -U gito -d gito > backup.sql
   ```

2. **Drop and recreate**
   ```bash
   docker exec gito-postgres psql -U gito -d gito -c "DROP SCHEMA public CASCADE; CREATE SCHEMA public;"
   ```

3. **Restart API** (applies all migrations from scratch)
   ```bash
   docker-compose restart api
   ```

---

## Team Workflow

### Code Review Checklist

When reviewing PRs with model changes:

- [ ] SQLAlchemy model is in `api/app/models/`
- [ ] Model is imported in `api/app/models/__init__.py`
- [ ] Migration file exists in `api/alembic/versions/`
- [ ] Migration matches model definition
- [ ] PR author tested migration locally
- [ ] Commit message mentions migration

### Merge Conflicts in Migrations

If two branches both create migrations:

1. **Keep both migration files**
2. **Fix the chain**:
   ```python
   # In newer migration, update down_revision
   down_revision = 'id_of_other_branch_migration'
   ```
3. **Test locally** - ensure both migrations apply in order

---

## Why Alembic?

**vs Manual SQL:**
- ✅ Auto-generates from models (fewer errors)
- ✅ Tracks what's applied
- ✅ Rollback support
- ✅ Works across all environments

**vs Custom Scripts:**
- ✅ Industry standard (every Python dev knows it)
- ✅ Battle-tested by thousands of companies
- ✅ Better tooling and documentation

**vs Django/Rails Migrations:**
- ✅ Same concept, different framework
- ✅ Alembic is for SQLAlchemy (FastAPI standard)

---

## Further Reading

- [Alembic Official Docs](https://alembic.sqlalchemy.org/)
- [Auto-generation Guide](https://alembic.sqlalchemy.org/en/latest/autogenerate.html)
- [Alembic Cookbook](https://alembic.sqlalchemy.org/en/latest/cookbook.html)

---

**Remember:** Migrations run automatically on API startup. Just create them, test them, and commit them!
