# Development & Deployment Workflow

Complete guide for developing locally and deploying to staging with GitHub Actions.

---

## Table of Contents

1. [Local Development Setup](#local-development-setup)
2. [Making Code Changes](#making-code-changes)
3. [Database Schema Changes with Alembic](#database-schema-changes-with-alembic)
4. [Testing Locally](#testing-locally)
5. [Git Workflow](#git-workflow)
6. [Staging Deployment (Automated)](#staging-deployment-automated)
7. [Monitoring & Verification](#monitoring--verification)
8. [Quick Reference Commands](#quick-reference-commands)
9. [Troubleshooting](#troubleshooting)

---

## Local Development Setup

### Starting the Stack

```bash
# Start all services
docker-compose up -d

# Check status
docker-compose ps

# View logs
docker-compose logs -f api web
```

### Services Running Locally

- **Web UI**: http://localhost:3000
- **API**: http://localhost:8000
- **API Docs**: http://localhost:8000/docs
- **PostgreSQL**: localhost:5432
- **MQTT**: localhost:1883
- **KeyDB**: localhost:6379

---

## Making Code Changes

### Backend (FastAPI/Python)

**Location**: `api/app/`

```bash
# Edit files - changes auto-reload via volume mount
# Example: api/app/routers/users.py

# No restart needed for most changes!
# API automatically reloads when you save files
```

**When restart IS needed:**
- Changes to `api/main.py` router registration
- Environment variable changes
- Dependency changes in `pyproject.toml`

```bash
docker-compose restart api
```

### Frontend (Next.js/React)

**Location**: `web/src/`

**Current Setup**: Production mode (requires rebuild)

```bash
# Edit files in web/src/
# After changes, rebuild:
docker-compose build web && docker-compose up -d web
```

**Recommended for faster development:**

Create `docker-compose.dev.yml`:
```yaml
version: '3.8'
services:
  web:
    command: npm run dev
    environment:
      NODE_ENV: development
```

Use dev mode:
```bash
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
# Now changes hot-reload instantly!
```

---

## Database Schema Changes with Alembic

### Workflow Overview

1. Edit SQLAlchemy models
2. Generate migration automatically
3. Review generated migration
4. Apply migration locally
5. Test changes
6. Commit migration file to Git

### Step-by-Step Example

**Scenario**: Adding a `department` field to the users table

#### Step 1: Update Model

Edit `api/app/models/base.py`:
```python
class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    tenant_id = Column(UUID(as_uuid=True), ForeignKey("tenants.id"), nullable=False)
    email = Column(String(255), nullable=False, unique=True)
    password_hash = Column(String(255), nullable=False)
    full_name = Column(String(255))
    department = Column(String(100))  # ‚Üê NEW FIELD
    role = Column(String(50), nullable=False)
    # ... rest of fields
```

#### Step 2: Generate Migration

```bash
# Auto-generate migration from model changes
docker exec gito-api alembic revision --autogenerate -m "add department to users"

# This creates: api/alembic/versions/abc123def456_add_department_to_users.py
```

#### Step 3: Review Generated Migration

```bash
# Check the generated file
cat api/alembic/versions/abc123def456_add_department_to_users.py
```

**Verify it contains:**
```python
def upgrade():
    op.add_column('users', sa.Column('department', sa.String(length=100), nullable=True))

def downgrade():
    op.drop_column('users', 'department')
```

**‚ö†Ô∏è Important:** Always review autogenerated migrations! Alembic can miss or misinterpret complex changes.

#### Step 4: Apply Migration Locally

```bash
# Apply the migration
docker exec gito-api alembic upgrade head

# Verify it worked
docker exec gito-api alembic current
# Should show: abc123def456 (head)
```

#### Step 5: Verify Database Change

```bash
# Check table structure
docker exec gito-postgres psql -U gito -d gito -c "\d users"

# Should show 'department' column
```

#### Step 6: Update Schemas & API

Edit `api/app/schemas/user.py`:
```python
class UserCreate(BaseModel):
    email: EmailStr
    password: str
    full_name: str
    department: Optional[str] = None  # ‚Üê Add field
    role: str = "VIEWER"
```

Edit `api/app/routers/users.py` if needed to handle the new field.

#### Step 7: Update Frontend

Edit `web/src/app/dashboard/users/page.tsx` to display/edit the department field.

---

## Testing Locally

### API Testing

```bash
# Check API health
curl http://localhost:8000/api/health

# Test endpoint (replace with your JWT token)
curl -H "Authorization: Bearer YOUR_TOKEN" \
     http://localhost:8000/api/v1/tenants/TENANT_ID/users

# View API logs
docker-compose logs api --tail 100 -f
```

### Frontend Testing

1. Open http://localhost:3000
2. Login with test credentials
3. Navigate to features you changed
4. Verify functionality works

### Database Verification

```bash
# Connect to database
docker exec -it gito-postgres psql -U gito -d gito

# Run queries
SELECT id, email, department FROM users;

# Check migration history
SELECT * FROM alembic_version;

# Exit
\q
```

---

## Git Workflow

### Branch Strategy

- **`main`**: Development branch (work here)
- **`staging`**: Staging deployment branch (deploy from here)
- **`production`**: Production branch (future)

### Committing Changes

#### 1. Check What Changed

```bash
git status
git diff
```

#### 2. Stage Files

```bash
# Stage specific files
git add api/app/routers/users.py
git add web/src/app/dashboard/users/page.tsx

# IMPORTANT: Always include migration files!
git add api/alembic/versions/*.py

# Or stage everything
git add .
```

#### 3. Commit with Clear Message

Use **conventional commits** format:

```bash
git commit -m "feat: add user department field

- Added department column to users table
- Created Alembic migration
- Updated UserCreate/UserUpdate schemas
- Added department field to user management UI
- Users can now be filtered by department

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

**Commit prefixes:**
- `feat:` - New feature
- `fix:` - Bug fix
- `docs:` - Documentation changes
- `refactor:` - Code refactoring
- `test:` - Test changes
- `chore:` - Build/config changes

#### 4. Push to Main

```bash
git push origin main
```

**‚ö†Ô∏è Note:** Pushing to `main` does NOT trigger staging deployment.

---

## Staging Deployment (Automated)

### Overview

Your staging server has a **self-hosted GitHub Actions runner** that automatically deploys when you push to the `staging` branch.

### Deployment Trigger

```bash
# After pushing changes to main and testing locally:

# 1. Switch to staging branch
git checkout staging

# 2. Merge main into staging
git merge main

# 3. Push to staging (this triggers deployment!)
git push origin staging
```

### What Happens Automatically

#### Phase 1: Build & Push (GitHub Actions)

**File**: `.github/workflows/staging-deploy.yml`

1. **Checkout code** from `staging` branch
2. **Login** to GitHub Container Registry (ghcr.io)
3. **Build API Docker image**
   - Context: `./api/Dockerfile`
   - Tag: `ghcr.io/your-repo-api:staging`
   - Includes all latest code + migration files
   - Pushes to registry
4. **Build Web Docker image**
   - Context: `./web/Dockerfile`
   - Tag: `ghcr.io/your-repo-web:staging`
   - Includes latest frontend build
   - Pushes to registry

#### Phase 2: Deploy to Staging Server

**Runs on**: Self-hosted runner (on staging server at `/opt/gito-iot`)

```bash
# 1. Navigate to app directory
cd /opt/gito-iot

# 2. Pull latest code
git pull origin staging

# 3. Login to container registry
echo "$GITHUB_TOKEN" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin

# 4. Pull latest Docker images
docker-compose -f docker-compose.staging.yml --env-file .env.staging pull

# 5. Restart all services
docker-compose -f docker-compose.staging.yml --env-file .env.staging up -d
```

#### Phase 3: Automatic Migration (entrypoint.sh)

When the API container starts:

```bash
#!/bin/bash
set -e

echo "Running database migrations..."
alembic upgrade head  # ‚Üê Applies all pending migrations!

echo "Starting API server..."
uvicorn app.main:app --host 0.0.0.0 --port 8000
```

**Alembic checks:**
- Current database version: `SELECT version_num FROM alembic_version;`
- Compares with migration files in `api/alembic/versions/`
- Applies any pending migrations in order
- Updates `alembic_version` table

#### Phase 4: Health Check

```bash
# Wait 30 seconds for services to start
sleep 30

# Check API health endpoint
curl -f https://staging-api.yourdomain.com/api/health || exit 1
```

If health check fails, deployment is marked as failed.

#### Phase 5: Cleanup

```bash
# Remove old unused Docker images
docker image prune -af
```

---

## Monitoring & Verification

### Watch GitHub Actions

1. Go to: `https://github.com/your-username/your-repo/actions`
2. Click on the latest "Deploy to Staging" workflow run
3. Watch real-time logs:
   - ‚úì Build and push API/Web images
   - ‚úì Deploy to staging server
   - ‚úì Health check

### Verify on Staging Server

If you have SSH access:

```bash
# SSH to staging
ssh user@staging-server

# Navigate to app directory
cd /opt/gito-iot

# Check running containers
docker-compose -f docker-compose.staging.yml ps

# View logs
docker-compose -f docker-compose.staging.yml logs -f api

# Check migration status
docker exec gito-api alembic current
# Should show: abc123def456 (head)

# Check specific migration in database
docker exec gito-postgres psql -U gito -d gito -c "SELECT * FROM alembic_version;"
```

### Access Staging Environment

- **Web**: https://staging.yourdomain.com
- **API**: https://staging-api.yourdomain.com
- **API Docs**: https://staging-api.yourdomain.com/docs

---

## Quick Reference Commands

### Local Development

```bash
# Start stack
docker-compose up -d

# View logs (all services)
docker-compose logs -f

# View specific service logs
docker-compose logs -f api
docker-compose logs -f web

# Restart service
docker-compose restart api

# Rebuild and restart
docker-compose build web && docker-compose up -d web

# Stop everything
docker-compose down

# Stop and remove volumes (DANGER!)
docker-compose down -v
```

### Alembic (Migrations)

```bash
# Check current migration version
docker exec gito-api alembic current

# Create new migration (auto-detect changes)
docker exec gito-api alembic revision --autogenerate -m "description"

# Create blank migration (manual)
docker exec gito-api alembic revision -m "description"

# Apply migrations
docker exec gito-api alembic upgrade head

# View migration history
docker exec gito-api alembic history

# Rollback one migration (CAUTION!)
docker exec gito-api alembic downgrade -1

# Rollback to specific version
docker exec gito-api alembic downgrade abc123def456
```

### Database

```bash
# Connect to PostgreSQL
docker exec -it gito-postgres psql -U gito -d gito

# Run single query
docker exec gito-postgres psql -U gito -d gito -c "SELECT * FROM users;"

# Describe table
docker exec gito-postgres psql -U gito -d gito -c "\d users"

# List all tables
docker exec gito-postgres psql -U gito -d gito -c "\dt"

# Check migration version
docker exec gito-postgres psql -U gito -d gito -c "SELECT * FROM alembic_version;"
```

### Git Workflow

```bash
# Development (main branch)
git checkout main
# ... make changes ...
git add .
git commit -m "feat: description"
git push origin main

# Deploy to staging
git checkout staging
git merge main
git push origin staging  # üöÄ Triggers deployment!

# Check GitHub Actions
# Visit: github.com/your-repo/actions
```

---

## Troubleshooting

### Migration Failed on Staging

**Symptom**: API container keeps restarting

**Check logs:**
```bash
docker-compose -f docker-compose.staging.yml logs api
# Look for Alembic errors
```

**Common issues:**

1. **Syntax error in migration**
   - Fix migration file locally
   - Test with `alembic upgrade head`
   - Commit and redeploy

2. **Conflicting migrations**
   - Multiple people created migrations simultaneously
   - Merge conflict in alembic_version table
   - Resolve by creating a merge migration:
   ```bash
   docker exec gito-api alembic merge -m "merge heads" head1 head2
   ```

3. **Database state mismatch**
   - Manual database changes not in migrations
   - Run Alembic autogenerate to catch up
   - Or manually fix migration script

### Frontend Changes Not Showing

**Symptom**: Pushed to staging but UI still shows old version

**Solution:**
```bash
# SSH to staging
ssh user@staging-server
cd /opt/gito-iot

# Force rebuild web container
docker-compose -f docker-compose.staging.yml build --no-cache web
docker-compose -f docker-compose.staging.yml up -d web

# Clear browser cache
# Hard refresh: Ctrl+Shift+R or Ctrl+F5
```

### Health Check Failing

**Symptom**: Deployment marked as failed

**Check:**
1. API is actually running:
   ```bash
   docker-compose -f docker-compose.staging.yml ps api
   ```

2. Health endpoint responds:
   ```bash
   curl -v https://staging-api.yourdomain.com/api/health
   ```

3. Check for port conflicts or certificate issues

### Cannot Connect to Database

**Symptom**: API logs show connection errors

**Check:**
1. PostgreSQL is running
2. Credentials in `.env.staging` are correct
3. Database exists:
   ```bash
   docker exec gito-postgres psql -U gito -l
   ```

---

## Complete Example: Adding a New Feature

### Scenario: Add user department field with filtering

#### 1. Local Development (on main branch)

```bash
# 1. Update model
# Edit api/app/models/base.py - add department column

# 2. Generate migration
docker exec gito-api alembic revision --autogenerate -m "add department to users"

# 3. Review migration
cat api/alembic/versions/abc123_add_department_to_users.py

# 4. Apply locally
docker exec gito-api alembic upgrade head

# 5. Verify
docker exec gito-postgres psql -U gito -d gito -c "\d users"

# 6. Update schemas
# Edit api/app/schemas/user.py - add department field

# 7. Update API logic
# Edit api/app/routers/users.py - add department filter

# 8. Update frontend
# Edit web/src/app/dashboard/users/page.tsx - show department

# 9. Test locally
docker-compose restart api
docker-compose build web && docker-compose up -d web
# Visit http://localhost:3000/dashboard/users
# Add test user with department
# Test filtering
```

#### 2. Commit Changes

```bash
git status
# Shows: api/app/models/base.py
#        api/alembic/versions/abc123_add_department_to_users.py
#        api/app/schemas/user.py
#        api/app/routers/users.py
#        web/src/app/dashboard/users/page.tsx

git add .
git commit -m "feat: add department field to user management

- Added department column to users table
- Created Alembic migration abc123
- Updated UserCreate and UserUpdate schemas
- Added department filter to list users endpoint
- Added department field and filter to UI
- Users can now be organized by department

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

git push origin main
```

#### 3. Deploy to Staging

```bash
git checkout staging
git merge main
git push origin staging  # üöÄ Deployment starts!
```

#### 4. Monitor Deployment

```bash
# Watch GitHub Actions
# Visit: github.com/your-repo/actions
# Click on "Deploy to Staging" workflow

# Or SSH to staging
ssh user@staging-server
cd /opt/gito-iot
docker-compose -f docker-compose.staging.yml logs -f api

# Look for:
# "Running database migrations..."
# "Running upgrade abc123 -> def456, add department to users"
# "Starting API server..."
```

#### 5. Verify on Staging

```bash
# Check migration applied
docker exec gito-api alembic current
# Should show: abc123_add_department_to_users (head)

# Access staging UI
# Visit: https://staging.yourdomain.com/dashboard/users
# Verify department field shows
# Test adding user with department
# Test department filter
```

---

## Best Practices

### ‚úÖ DO:

- **Always test locally first** before deploying to staging
- **Commit migration files** - they must be in version control
- **Review autogenerated migrations** - Alembic can make mistakes
- **Use descriptive migration messages** - help future you understand changes
- **Test migrations both upgrade AND downgrade** (if writing custom ones)
- **Keep migrations small and focused** - one logical change per migration
- **Add database indexes** in separate migrations from table creation
- **Use conventional commit messages** - makes changelog easier
- **Check GitHub Actions logs** after deployment

### ‚ùå DON'T:

- **Never edit applied migrations** - create a new migration instead
- **Never delete migration files** that have been applied to any environment
- **Don't run `alembic downgrade`** in production without backups
- **Don't commit `.next/` or `node_modules/`** (in .gitignore)
- **Don't commit `.env` or `.env.staging`** (secrets!)
- **Don't push directly to staging** - always merge from main
- **Don't skip testing locally** - staging is shared environment
- **Don't make manual database changes** - always use migrations

---

## Additional Resources

- [Alembic Documentation](https://alembic.sqlalchemy.org/)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Docker Compose Documentation](https://docs.docker.com/compose/)
- [Next.js Production Deployment](https://nextjs.org/docs/deployment)
- [FastAPI Best Practices](https://fastapi.tiangolo.com/deployment/)

---

## Getting Help

**Common issues documented here:**
- See [MIGRATIONS.md](./MIGRATIONS.md) for detailed Alembic troubleshooting
- Check GitHub Actions logs for deployment failures
- Review Docker logs for runtime issues

**For new issues:**
1. Check logs first (API, Web, database)
2. Verify migration status with `alembic current`
3. Check GitHub Actions workflow logs
4. Review recent commits for breaking changes

---

**Last Updated**: 2025-02-05
